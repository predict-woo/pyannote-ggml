<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whisper JSON Viewer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f5f5f7;
            color: #1d1d1f;
            min-height: 100vh;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 24px;
            color: #1d1d1f;
            font-weight: 600;
            font-size: 28px;
        }

        h2 {
            font-size: 18px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 14px;
        }

        .container {
            max-width: 1500px;
            margin: 0 auto;
        }

        .file-inputs {
            display: flex;
            gap: 20px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        .file-input-group {
            flex: 1;
            min-width: 250px;
        }

        .file-input-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #1d1d1f;
        }

        .file-drop {
            width: 100%;
            min-height: 84px;
            padding: 14px;
            background: #fff;
            border: 2px dashed #86868b;
            border-radius: 12px;
            color: #1d1d1f;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: 500;
            position: relative;
        }

        .file-drop:hover,
        .file-drop.drag-over {
            border-color: #0071e3;
            background: #f0f7ff;
        }

        .file-drop input[type="file"] {
            position: absolute;
            inset: 0;
            opacity: 0;
            cursor: pointer;
        }

        .player-section,
        .stats-section,
        .segments-section,
        .comparison-section,
        .keyboard-shortcuts {
            background: #fff;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .play-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            background: #0071e3;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, transform 0.1s;
            box-shadow: 0 4px 12px rgba(0,113,227,0.3);
        }

        .play-btn:hover {
            background: #0077ed;
            transform: scale(1.05);
        }

        .play-btn:active {
            transform: scale(0.98);
        }

        .play-btn:disabled {
            background: #d2d2d7;
            cursor: not-allowed;
            box-shadow: none;
        }

        .time-display {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 16px;
            color: #1d1d1f;
            font-weight: 500;
            min-width: 140px;
        }

        .current-token-display {
            flex: 1;
            text-align: center;
            padding: 8px 16px;
            background: #f5f5f7;
            border-radius: 12px;
            min-width: 240px;
        }

        .current-token-label {
            font-size: 11px;
            color: #86868b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .current-token-text {
            font-size: 20px;
            font-weight: 700;
            color: #1d1d1f;
            min-height: 28px;
            line-height: 1.3;
            white-space: pre-wrap;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speed-control label {
            font-size: 14px;
            color: #86868b;
            font-weight: 500;
        }

        .speed-control select {
            background: #f5f5f7;
            border: 1px solid #d2d2d7;
            color: #1d1d1f;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .speed-control select:hover {
            border-color: #0071e3;
        }

        .timeline-container {
            position: relative;
            background: #e8e8ed;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            user-select: none;
        }

        .timeline-track {
            height: 72px;
            position: relative;
        }

        .timeline-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #86868b;
            font-size: 14px;
            pointer-events: none;
            font-weight: 500;
            z-index: 1;
        }

        .segment-block {
            position: absolute;
            top: 14px;
            height: 44px;
            border-radius: 7px;
            border: 1px solid rgba(255,255,255,0.6);
            opacity: 0.75;
            transition: opacity 0.12s, transform 0.12s;
        }

        .segment-block.active {
            opacity: 1;
            transform: translateY(-1px);
        }

        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #ff3b30;
            pointer-events: none;
            z-index: 100;
        }

        .playhead::before {
            content: '';
            position: absolute;
            top: -6px;
            left: -6px;
            width: 15px;
            height: 15px;
            background: #ff3b30;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 2px 8px rgba(255,59,48,0.4);
        }

        .scrub-bar {
            height: 6px;
            background: #d2d2d7;
        }

        .scrub-progress {
            height: 100%;
            background: #0071e3;
            width: 0;
        }

        .content-grid {
            display: grid;
            grid-template-columns: minmax(0, 1.8fr) minmax(300px, 0.9fr);
            gap: 24px;
            align-items: start;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px;
        }

        .stat-card {
            background: #f5f5f7;
            border-radius: 12px;
            padding: 12px;
        }

        .stat-value {
            font-size: 21px;
            font-weight: 700;
            color: #1d1d1f;
            line-height: 1.1;
            word-break: break-word;
        }

        .stat-label {
            margin-top: 4px;
            font-size: 12px;
            color: #86868b;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            font-weight: 600;
        }

        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 5px 10px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            margin-top: 14px;
        }

        .status-pill.ok {
            background: rgba(52,199,89,0.14);
            color: #248a3d;
        }

        .status-pill.warn {
            background: rgba(255,149,0,0.14);
            color: #a86900;
        }

        .segments-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 12px;
            margin-bottom: 14px;
            flex-wrap: wrap;
        }

        .segments-note {
            font-size: 13px;
            color: #86868b;
            font-weight: 500;
        }

        .segment-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 920px;
            overflow: auto;
            padding-right: 4px;
        }

        .segment-card {
            background: #f8f8fa;
            border-radius: 12px;
            border-left: 4px solid #d2d2d7;
            padding: 12px;
            cursor: pointer;
            transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
        }

        .segment-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        .segment-card.active {
            background: #eef6ff;
            border-left-color: #0071e3;
            box-shadow: 0 0 0 2px rgba(0,113,227,0.2), 0 6px 16px rgba(0,0,0,0.1);
        }

        .segment-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .segment-time {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px;
            color: #86868b;
            font-weight: 600;
        }

        .segment-count {
            font-size: 11px;
            color: #86868b;
            font-weight: 600;
            text-transform: uppercase;
        }

        .token-strip,
        .token-strip-dtw {
            height: 18px;
            border-radius: 8px;
            background: #e8e8ed;
            position: relative;
            overflow: hidden;
            margin-bottom: 8px;
            border: 1px solid rgba(0,0,0,0.04);
        }

        .token-strip-dtw {
            background: #f1f1f5;
            margin-bottom: 10px;
        }

        .token-strip-label {
            font-size: 10px;
            color: #86868b;
            font-weight: 700;
            letter-spacing: 0.4px;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .token-block {
            position: absolute;
            top: 0;
            bottom: 0;
            border-right: 1px solid rgba(255,255,255,0.65);
            opacity: 0.85;
            transition: opacity 0.1s ease, box-shadow 0.1s ease;
        }

        .token-block.active {
            opacity: 1;
            box-shadow: inset 0 0 0 2px rgba(255,59,48,0.95);
        }

        .segment-text {
            font-size: 15px;
            line-height: 1.7;
            white-space: pre-wrap;
            margin-bottom: 10px;
        }

        .token-span {
            border-radius: 4px;
            padding: 1px 0;
            cursor: pointer;
            transition: background 0.1s ease, box-shadow 0.1s ease;
            position: relative;
        }

        .token-span:hover {
            background: rgba(0,113,227,0.1);
        }

        .token-span.active {
            background: rgba(255,59,48,0.2);
            box-shadow: 0 2px 0 0 #ff3b30;
        }

        .token-span.conf-low {
            text-decoration: underline wavy rgba(255,59,48,0.5);
            text-underline-offset: 3px;
        }

        .token-tooltip {
            display: none;
            position: absolute;
            bottom: calc(100% + 6px);
            left: 50%;
            transform: translateX(-50%);
            background: #1d1d1f;
            color: #fff;
            padding: 6px 10px;
            border-radius: 8px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 11px;
            white-space: nowrap;
            z-index: 200;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            line-height: 1.4;
        }

        .token-span:hover .token-tooltip,
        .token-span.active .token-tooltip {
            display: block;
        }

        .token-block.conf-high { background: rgba(52,199,89,0.8); }
        .token-block.conf-mid { background: rgba(255,214,10,0.85); }
        .token-block.conf-low { background: rgba(255,59,48,0.78); }

        .empty-state {
            background: #f5f5f7;
            border-radius: 12px;
            min-height: 140px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #86868b;
            padding: 22px;
            font-size: 15px;
            font-weight: 500;
        }

        .comparison-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px;
            margin-top: 8px;
        }

        .compare-col {
            background: #f8f8fa;
            border-radius: 12px;
            padding: 10px;
        }

        .compare-title {
            font-size: 13px;
            font-weight: 700;
            margin-bottom: 8px;
            color: #1d1d1f;
        }

        .compare-token {
            font-size: 12px;
            padding: 6px 8px;
            border-radius: 8px;
            margin-bottom: 6px;
            background: #fff;
            border: 1px solid rgba(0,0,0,0.05);
            white-space: pre-wrap;
        }

        .compare-token.diff {
            border-color: rgba(255,59,48,0.5);
            background: rgba(255,59,48,0.08);
        }

        .compare-meta {
            margin-top: 2px;
            color: #616168;
            font-size: 11px;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .keyboard-shortcuts h3 {
            font-size: 14px;
            margin-bottom: 12px;
            color: #1d1d1f;
            font-weight: 600;
        }

        .shortcuts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 10px;
        }

        .shortcut {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            color: #1d1d1f;
        }

        .shortcut kbd {
            background: #f5f5f7;
            padding: 4px 8px;
            border-radius: 6px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px;
            border: 1px solid #d2d2d7;
            font-weight: 500;
        }

        @media (max-width: 1060px) {
            .content-grid {
                grid-template-columns: 1fr;
            }

            .segment-list {
                max-height: none;
            }

            .comparison-columns {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 720px) {
            .controls {
                align-items: stretch;
            }

            .current-token-display {
                order: 4;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Whisper JSON Viewer</h1>

        <div class="file-inputs">
            <div class="file-input-group">
                <label>Audio File (WAV)</label>
                <div class="file-drop" id="audioDrop">
                    <span id="audioDropText">Drop audio file here or click to choose</span>
                    <input type="file" id="audioFile" accept="audio/*">
                </div>
            </div>
            <div class="file-input-group">
                <label>Whisper JSON (`--output-json-full`)</label>
                <div class="file-drop" id="jsonDrop">
                    <span id="jsonDropText">Drop primary JSON here or click to choose</span>
                    <input type="file" id="jsonFile" accept=".json,application/json">
                </div>
            </div>
            <div class="file-input-group">
                <label>Comparison JSON (optional)</label>
                <div class="file-drop" id="jsonCompareDrop">
                    <span id="jsonCompareDropText">Drop second JSON for side-by-side compare</span>
                    <input type="file" id="jsonCompareFile" accept=".json,application/json">
                </div>
            </div>
        </div>

        <div class="player-section">
            <div class="controls">
                <button class="play-btn" id="playBtn" disabled><span id="playIcon">▶</span></button>
                <div class="time-display"><span id="currentTime">0:00.0</span> / <span id="totalTime">0:00.0</span></div>

                <div class="current-token-display">
                    <div class="current-token-label">Current Token</div>
                    <div class="current-token-text" id="currentToken">—</div>
                </div>

                <div class="speed-control">
                    <label>Speed:</label>
                    <select id="speedSelect">
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1" selected>1x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                    </select>
                </div>
            </div>

            <div class="timeline-container" id="timelineContainer">
                <div class="timeline-track" id="timelineTrack">
                    <div class="timeline-placeholder" id="timelinePlaceholder">Load audio and whisper JSON to begin</div>
                    <div class="playhead" id="playhead" style="left: 0"></div>
                </div>
                <div class="scrub-bar"><div class="scrub-progress" id="scrubProgress"></div></div>
            </div>
        </div>

        <div class="content-grid">
            <div class="segments-section">
                <div class="segments-header">
                    <h2>Segments & Tokens</h2>
                    <div class="segments-note">Click a segment to seek and expand token detail.</div>
                </div>
                <div class="segment-list" id="segmentList">
                    <div class="empty-state">Load whisper JSON to inspect token-level timestamps.</div>
                </div>
            </div>

            <div class="stats-section">
                <h2>Run Stats</h2>
                <div class="stats-grid">
                    <div class="stat-card"><div class="stat-value" id="statModel">—</div><div class="stat-label">Model</div></div>
                    <div class="stat-card"><div class="stat-value" id="statLang">—</div><div class="stat-label">Language</div></div>
                    <div class="stat-card"><div class="stat-value" id="statSegments">0</div><div class="stat-label">Segments</div></div>
                    <div class="stat-card"><div class="stat-value" id="statTokens">0</div><div class="stat-label">Tokens</div></div>
                    <div class="stat-card"><div class="stat-value" id="statAvgP">—</div><div class="stat-label">Avg Confidence</div></div>
                    <div class="stat-card"><div class="stat-value" id="statDuration">0:00.0</div><div class="stat-label">Timeline Span</div></div>
                </div>
                <div class="status-pill warn" id="dtwStatus">No DTW data</div>
            </div>
        </div>

        <div class="comparison-section" id="comparisonSection" style="display:none">
            <h2>Comparison Overlay (Primary vs Secondary)</h2>
            <div class="segments-note" id="comparisonSummary">Load a second JSON to compare timestamp differences for the active segment.</div>
            <div class="comparison-columns" id="comparisonColumns">
                <div class="compare-col"><div class="compare-title">Primary</div><div id="comparePrimary"></div></div>
                <div class="compare-col"><div class="compare-title">Secondary</div><div id="compareSecondary"></div></div>
            </div>
        </div>

        <div class="keyboard-shortcuts">
            <h3>Keyboard Shortcuts</h3>
            <div class="shortcuts-grid">
                <div class="shortcut"><kbd>Space</kbd> Play / Pause</div>
                <div class="shortcut"><kbd>←</kbd> Back 5s</div>
                <div class="shortcut"><kbd>→</kbd> Forward 5s</div>
                <div class="shortcut"><kbd>J</kbd> Back 1s</div>
                <div class="shortcut"><kbd>L</kbd> Forward 1s</div>
                <div class="shortcut"><kbd>Home</kbd> Go to start</div>
                <div class="shortcut"><kbd>N</kbd> Next segment</div>
                <div class="shortcut"><kbd>P</kbd> Previous segment</div>
            </div>
        </div>
    </div>

    <audio id="audioPlayer"></audio>

    <script>
        const SEGMENT_COLORS = ['#007aff', '#5ac8fa', '#34c759', '#ff9500', '#af52de', '#00c7be', '#ff2d55', '#5856d6'];

        let primaryData = null;
        let compareData = null;
        let duration = 0;
        let activeSegmentIndex = -1;
        let activeTokenIndex = -1;
        let animationFrame = 0;
        let isScrubbing = false;

        const audioPlayer = document.getElementById('audioPlayer');
        const audioFileInput = document.getElementById('audioFile');
        const jsonFileInput = document.getElementById('jsonFile');
        const jsonCompareFileInput = document.getElementById('jsonCompareFile');
        const playBtn = document.getElementById('playBtn');
        const playIcon = document.getElementById('playIcon');
        const currentTimeEl = document.getElementById('currentTime');
        const totalTimeEl = document.getElementById('totalTime');
        const currentTokenEl = document.getElementById('currentToken');
        const speedSelect = document.getElementById('speedSelect');
        const timelineContainer = document.getElementById('timelineContainer');
        const timelineTrack = document.getElementById('timelineTrack');
        const timelinePlaceholder = document.getElementById('timelinePlaceholder');
        const playhead = document.getElementById('playhead');
        const scrubProgress = document.getElementById('scrubProgress');
        const segmentList = document.getElementById('segmentList');
        const comparisonSection = document.getElementById('comparisonSection');
        const comparisonSummary = document.getElementById('comparisonSummary');
        const comparePrimary = document.getElementById('comparePrimary');
        const compareSecondary = document.getElementById('compareSecondary');

        const statModel = document.getElementById('statModel');
        const statLang = document.getElementById('statLang');
        const statSegments = document.getElementById('statSegments');
        const statTokens = document.getElementById('statTokens');
        const statAvgP = document.getElementById('statAvgP');
        const statDuration = document.getElementById('statDuration');
        const dtwStatus = document.getElementById('dtwStatus');

        function formatTime(seconds) {
            const safe = Math.max(0, Number(seconds) || 0);
            const mins = Math.floor(safe / 60);
            const secs = (safe % 60).toFixed(1);
            return `${mins}:${secs.padStart(4, '0')}`;
        }

        function formatMs(ms) {
            return formatTime((Number(ms) || 0) / 1000);
        }

        function parseClockTimeToMs(value) {
            if (typeof value !== 'string') return NaN;
            const match = value.trim().match(/^(\d+):(\d+):(\d+),(\d{1,3})$/);
            if (!match) return NaN;
            const h = Number(match[1]);
            const m = Number(match[2]);
            const s = Number(match[3]);
            const ms = Number(match[4].padEnd(3, '0'));
            return (((h * 60) + m) * 60 + s) * 1000 + ms;
        }

        function parseOffsetMs(node, key) {
            if (Number.isFinite(Number(node?.offsets?.[key]))) {
                return Number(node.offsets[key]);
            }
            if (node?.timestamps?.[key]) {
                const parsed = parseClockTimeToMs(node.timestamps[key]);
                if (Number.isFinite(parsed)) return parsed;
            }
            return NaN;
        }

        function confidenceClass(prob) {
            const p = Number(prob);
            if (!Number.isFinite(p) || p >= 0.9) return 'conf-high';
            if (p >= 0.5) return 'conf-mid';
            return 'conf-low';
        }

        function decodeTextWithFallback(buffer) {
            // Whisper BPE tokenizer splits Korean characters mid-byte, producing
            // invalid UTF-8 in individual token "text" fields. Use non-fatal UTF-8
            // decoding which replaces broken sequences with U+FFFD (�) — this is
            // correct because the split bytes are expected for sub-word tokens.
            return new TextDecoder('utf-8', { fatal: false }).decode(buffer);
        }

        function parseWhisperJsonObject(parsed) {
            if (!parsed || !Array.isArray(parsed.transcription)) {
                throw new Error('Invalid whisper JSON. Expected a "transcription" array.');
            }

            const segments = parsed.transcription.map((segment, segIdx) => {
                const segFrom = parseOffsetMs(segment, 'from');
                const segTo = parseOffsetMs(segment, 'to');
                const tokensRaw = Array.isArray(segment.tokens) ? segment.tokens : [];
                const segmentStartMs = Number.isFinite(segFrom) ? segFrom : (segIdx === 0 ? 0 : NaN);
                const segmentEndMs = Number.isFinite(segTo) ? segTo : NaN;

                const tokens = tokensRaw.map((token, tokIdx) => {
                    const from = parseOffsetMs(token, 'from');
                    const to = parseOffsetMs(token, 'to');
                    const fallbackStart = Number.isFinite(from) ? from : (Number.isFinite(segmentStartMs) ? segmentStartMs : 0);
                    const fallbackEnd = Number.isFinite(to) ? Math.max(to, fallbackStart) : fallbackStart;
                    const dtwRaw = Number(token.t_dtw);
                    const dtwSec = Number.isFinite(dtwRaw) ? dtwRaw / 100 : null;

                    return {
                        index: tokIdx,
                        text: String(token.text ?? ''),
                        id: token.id,
                        p: Number(token.p),
                        startMs: fallbackStart,
                        endMs: fallbackEnd,
                        dtwSec
                    };
                });

                let startMs = segmentStartMs;
                let endMs = segmentEndMs;

                if (!Number.isFinite(startMs)) {
                    startMs = tokens.length ? Math.min(...tokens.map((t) => t.startMs)) : 0;
                }
                if (!Number.isFinite(endMs)) {
                    endMs = tokens.length ? Math.max(...tokens.map((t) => t.endMs)) : startMs;
                }

                return {
                    index: segIdx,
                    text: String(segment.text ?? ''),
                    startMs,
                    endMs: Math.max(endMs, startMs),
                    tokens
                };
            }).sort((a, b) => a.startMs - b.startMs);

            const tokenCount = segments.reduce((sum, seg) => sum + seg.tokens.length, 0);
            const confidenceValues = segments.flatMap((seg) => seg.tokens.map((token) => token.p)).filter((p) => Number.isFinite(p));
            const avgConfidence = confidenceValues.length
                ? confidenceValues.reduce((sum, p) => sum + p, 0) / confidenceValues.length
                : null;

            const hasDtw = segments.some((seg) => seg.tokens.some((token) => token.dtwSec != null));
            const spanMs = segments.length ? Math.max(...segments.map((seg) => seg.endMs)) : 0;
            const modelLabel = String(parsed.model?.type || parsed.params?.model || 'unknown');
            const language = String(parsed.result?.language || parsed.params?.language || 'unknown');

            return {
                modelLabel,
                language,
                segments,
                tokenCount,
                avgConfidence,
                hasDtw,
                spanMs
            };
        }

        async function loadWhisperFile(file) {
            const buffer = await file.arrayBuffer();
            const text = decodeTextWithFallback(buffer);
            const parsed = JSON.parse(text);
            return parseWhisperJsonObject(parsed);
        }

        function getTotalDurationSeconds() {
            const fromData = (primaryData && primaryData.spanMs > 0) ? primaryData.spanMs / 1000 : 0;
            return Math.max(duration || 0, fromData);
        }

        function clampTime(sec) {
            const max = getTotalDurationSeconds();
            return Math.min(Math.max(0, sec), max > 0 ? max : sec);
        }

        function getActiveSegmentIndex(timeSec) {
            if (!primaryData) return -1;
            const ms = timeSec * 1000;
            for (let i = 0; i < primaryData.segments.length; i++) {
                const segment = primaryData.segments[i];
                if (ms >= segment.startMs && ms <= segment.endMs) return i;
            }
            return -1;
        }

        function getActiveTokenIndex(segment, timeSec) {
            if (!segment) return -1;
            const ms = timeSec * 1000;
            for (let i = 0; i < segment.tokens.length; i++) {
                const token = segment.tokens[i];
                if (ms >= token.startMs && ms <= token.endMs) return i;
            }
            return -1;
        }

        function createTokenBlock(startMs, endMs, segStart, segDurationMs, className, isActive) {
            const el = document.createElement('div');
            const safeDuration = Math.max(segDurationMs, 1);
            const leftPct = ((startMs - segStart) / safeDuration) * 100;
            const widthPct = Math.max(((endMs - startMs) / safeDuration) * 100, 0.4);
            el.className = `token-block ${className}${isActive ? ' active' : ''}`;
            el.style.left = `${Math.max(0, leftPct)}%`;
            el.style.width = `${Math.min(100 - Math.max(0, leftPct), widthPct)}%`;
            return el;
        }

        function buildTokenStrip(segment, activeTokIdx) {
            const strip = document.createElement('div');
            strip.className = 'token-strip';
            const segDurationMs = Math.max(segment.endMs - segment.startMs, 1);

            segment.tokens.forEach((token, idx) => {
                const block = createTokenBlock(
                    token.startMs,
                    Math.max(token.endMs, token.startMs + 10),
                    segment.startMs,
                    segDurationMs,
                    confidenceClass(token.p),
                    idx === activeTokIdx
                );
                strip.appendChild(block);
            });
            return strip;
        }

        function buildDtwStrip(segment, activeTokIdx) {
            if (!segment.tokens.some((token) => token.dtwSec != null)) return null;
            const label = document.createElement('div');
            label.className = 'token-strip-label';
            label.textContent = 'DTW boundaries';

            const strip = document.createElement('div');
            strip.className = 'token-strip-dtw';
            const segDurationMs = Math.max(segment.endMs - segment.startMs, 1);

            for (let i = 0; i < segment.tokens.length; i++) {
                const token = segment.tokens[i];
                if (token.dtwSec == null) continue;
                const dtwStartMs = token.dtwSec * 1000;
                let dtwEndMs = token.endMs;
                const next = segment.tokens[i + 1];
                if (next && next.dtwSec != null) {
                    dtwEndMs = Math.max(next.dtwSec * 1000, dtwStartMs + 10);
                } else {
                    dtwEndMs = Math.max(dtwEndMs, dtwStartMs + 10);
                }

                const block = createTokenBlock(
                    Math.max(segment.startMs, dtwStartMs),
                    Math.min(segment.endMs, dtwEndMs),
                    segment.startMs,
                    segDurationMs,
                    confidenceClass(token.p),
                    i === activeTokIdx
                );
                strip.appendChild(block);
            }

            return { label, strip };
        }

        function buildTokenSpan(token, segIndex, tokIndex, active) {
            const span = document.createElement('span');
            const isSpecial = token.text.startsWith('[');
            if (isSpecial) return null; // skip special tokens like [_BEG_], [_TT_...]

            span.className = `token-span ${confidenceClass(token.p)}${active ? ' active' : ''}`;
            span.dataset.segmentIndex = String(segIndex);
            span.dataset.tokenIndex = String(tokIndex);
            span.textContent = token.text;

            const tooltip = document.createElement('div');
            tooltip.className = 'token-tooltip';
            const pVal = Number.isFinite(token.p) ? token.p.toFixed(3) : 'n/a';
            const defaultTs = `${formatMs(token.startMs)} → ${formatMs(token.endMs)}`;
            const dtwText = token.dtwSec != null ? `\nDTW: ${formatTime(token.dtwSec)}` : '';
            tooltip.textContent = `p=${pVal}  ${defaultTs}${dtwText}`;
            span.appendChild(tooltip);

            span.addEventListener('click', (event) => {
                event.stopPropagation();
                audioPlayer.currentTime = clampTime(token.startMs / 1000);
                updatePlaybackUI(true);
            });

            return span;
        }

        function renderTimelineSegments() {
            timelineTrack.querySelectorAll('.segment-block').forEach((el) => {
                el.remove();
            });
            if (!primaryData || !primaryData.segments.length) return;

            const totalSec = getTotalDurationSeconds();
            if (!totalSec) return;

            primaryData.segments.forEach((segment, idx) => {
                const block = document.createElement('div');
                const left = (segment.startMs / 1000 / totalSec) * 100;
                const width = Math.max(((segment.endMs - segment.startMs) / 1000 / totalSec) * 100, 0.15);
                block.className = 'segment-block';
                block.style.left = `${left}%`;
                block.style.width = `${Math.min(100 - left, width)}%`;
                block.style.background = SEGMENT_COLORS[idx % SEGMENT_COLORS.length];
                block.dataset.segmentIndex = String(idx);
                block.addEventListener('click', (event) => {
                    event.stopPropagation();
                    audioPlayer.currentTime = clampTime(segment.startMs / 1000);
                    updatePlaybackUI(true);
                });
                timelineTrack.appendChild(block);
            });
        }

        function renderStats() {
            if (!primaryData) {
                statModel.textContent = '—';
                statLang.textContent = '—';
                statSegments.textContent = '0';
                statTokens.textContent = '0';
                statAvgP.textContent = '—';
                statDuration.textContent = '0:00.0';
                dtwStatus.className = 'status-pill warn';
                dtwStatus.textContent = 'No DTW data';
                return;
            }

            statModel.textContent = primaryData.modelLabel;
            statLang.textContent = primaryData.language;
            statSegments.textContent = String(primaryData.segments.length);
            statTokens.textContent = String(primaryData.tokenCount);
            statAvgP.textContent = primaryData.avgConfidence == null ? '—' : primaryData.avgConfidence.toFixed(3);
            statDuration.textContent = formatTime(primaryData.spanMs / 1000);

            if (primaryData.hasDtw) {
                dtwStatus.className = 'status-pill ok';
                dtwStatus.textContent = 'DTW data present';
            } else {
                dtwStatus.className = 'status-pill warn';
                dtwStatus.textContent = 'No DTW data';
            }
        }

        function renderSegments() {
            if (!primaryData || !primaryData.segments.length) {
                segmentList.innerHTML = '<div class="empty-state">Load whisper JSON to inspect token-level timestamps.</div>';
                return;
            }

            segmentList.innerHTML = '';

            primaryData.segments.forEach((segment, segIdx) => {
                const card = document.createElement('div');
                card.className = 'segment-card';
                card.dataset.segmentIndex = String(segIdx);
                if (segIdx === activeSegmentIndex) card.classList.add('active');

                const meta = document.createElement('div');
                meta.className = 'segment-meta';
                const time = document.createElement('div');
                time.className = 'segment-time';
                time.textContent = `${formatMs(segment.startMs)} -> ${formatMs(segment.endMs)}`;
                const count = document.createElement('div');
                count.className = 'segment-count';
                count.textContent = `${segment.tokens.length} token${segment.tokens.length === 1 ? '' : 's'}`;
                meta.appendChild(time);
                meta.appendChild(count);
                card.appendChild(meta);

                const text = document.createElement('div');
                text.className = 'segment-text';
                segment.tokens.forEach((token, tokIdx) => {
                    const span = buildTokenSpan(token, segIdx, tokIdx, segIdx === activeSegmentIndex && tokIdx === activeTokenIndex);
                    if (span) text.appendChild(span);
                });
                card.appendChild(text);

                const tokenStrip = buildTokenStrip(segment, segIdx === activeSegmentIndex ? activeTokenIndex : -1);
                card.appendChild(tokenStrip);

                const dtwStripBundle = buildDtwStrip(segment, segIdx === activeSegmentIndex ? activeTokenIndex : -1);
                if (dtwStripBundle) {
                    card.appendChild(dtwStripBundle.label);
                    card.appendChild(dtwStripBundle.strip);
                }

                card.addEventListener('click', () => {
                    audioPlayer.currentTime = clampTime(segment.startMs / 1000);
                    updatePlaybackUI(true);
                });

                segmentList.appendChild(card);
            });
        }

        function renderComparison() {
            if (!compareData || !primaryData) {
                comparisonSection.style.display = 'none';
                return;
            }

            comparisonSection.style.display = 'block';
            comparePrimary.innerHTML = '';
            compareSecondary.innerHTML = '';

            const segIndex = activeSegmentIndex >= 0 ? activeSegmentIndex : 0;
            const segA = primaryData.segments[segIndex];
            const segB = compareData.segments[segIndex];

            if (!segA || !segB) {
                comparisonSummary.textContent = 'Segment counts differ. Showing only shared indices.';
                return;
            }

            let diffCount = 0;
            const minLen = Math.min(segA.tokens.length, segB.tokens.length);

            for (let i = 0; i < minLen; i++) {
                const tokenA = segA.tokens[i];
                const tokenB = segB.tokens[i];
                const deltaStart = Math.abs(tokenA.startMs - tokenB.startMs);
                const deltaEnd = Math.abs(tokenA.endMs - tokenB.endMs);
                const isDiff = deltaStart > 40 || deltaEnd > 40;
                if (isDiff) diffCount++;

                const colA = document.createElement('div');
                colA.className = `compare-token${isDiff ? ' diff' : ''}`;
                colA.textContent = tokenA.text || ' ';
                const metaA = document.createElement('div');
                metaA.className = 'compare-meta';
                metaA.textContent = `${formatMs(tokenA.startMs)} -> ${formatMs(tokenA.endMs)}${tokenA.dtwSec != null ? ` | DTW ${formatTime(tokenA.dtwSec)}` : ''}`;
                colA.appendChild(metaA);
                comparePrimary.appendChild(colA);

                const colB = document.createElement('div');
                colB.className = `compare-token${isDiff ? ' diff' : ''}`;
                colB.textContent = tokenB.text || ' ';
                const metaB = document.createElement('div');
                metaB.className = 'compare-meta';
                metaB.textContent = `${formatMs(tokenB.startMs)} -> ${formatMs(tokenB.endMs)}${tokenB.dtwSec != null ? ` | DTW ${formatTime(tokenB.dtwSec)}` : ''}`;
                colB.appendChild(metaB);
                compareSecondary.appendChild(colB);
            }

            const mismatchTail = Math.abs(segA.tokens.length - segB.tokens.length);
            comparisonSummary.textContent = `Segment #${segIndex + 1}: ${diffCount}/${minLen} tokens differ (>40ms), token count delta ${mismatchTail}.`;
        }

        function updateCurrentTokenDisplay(segment, tokenIndex) {
            if (!segment || tokenIndex < 0 || !segment.tokens[tokenIndex]) {
                currentTokenEl.textContent = '—';
                return;
            }
            currentTokenEl.textContent = segment.tokens[tokenIndex].text || ' ';
        }

        function updatePlaybackUI(forceRender) {
            const time = audioPlayer.currentTime || 0;
            const totalSec = getTotalDurationSeconds();
            const progress = totalSec > 0 ? Math.min(time / totalSec, 1) : 0;

            playhead.style.left = `${progress * 100}%`;
            scrubProgress.style.width = `${progress * 100}%`;
            currentTimeEl.textContent = formatTime(time);
            totalTimeEl.textContent = formatTime(totalSec);

            const segIdx = getActiveSegmentIndex(time);
            const tokenIdx = segIdx >= 0 ? getActiveTokenIndex(primaryData.segments[segIdx], time) : -1;

            const changed = segIdx !== activeSegmentIndex || tokenIdx !== activeTokenIndex;
            activeSegmentIndex = segIdx;
            activeTokenIndex = tokenIdx;

            const currentSegment = segIdx >= 0 ? primaryData.segments[segIdx] : null;
            updateCurrentTokenDisplay(currentSegment, tokenIdx);

            if (changed || forceRender) {
                timelineTrack.querySelectorAll('.segment-block').forEach((el) => {
                    const idx = Number(el.dataset.segmentIndex);
                    el.classList.toggle('active', idx === activeSegmentIndex);
                });

                renderSegments();
                renderComparison();

                if (activeSegmentIndex >= 0) {
                    const activeNode = document.querySelector(`.segment-card[data-segment-index="${activeSegmentIndex}"]`);
                    if (activeNode) {
                        activeNode.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }
            }
        }

        function playbackLoop() {
            updatePlaybackUI(false);
            if (!audioPlayer.paused && !audioPlayer.ended) {
                animationFrame = requestAnimationFrame(playbackLoop);
            }
        }

        function startPlaybackLoop() {
            cancelAnimationFrame(animationFrame);
            animationFrame = requestAnimationFrame(playbackLoop);
        }

        function stopPlaybackLoop() {
            cancelAnimationFrame(animationFrame);
        }

        function seekFromClientX(clientX) {
            const totalSec = getTotalDurationSeconds();
            if (!totalSec) return;
            const rect = timelineContainer.getBoundingClientRect();
            const ratio = (clientX - rect.left) / rect.width;
            audioPlayer.currentTime = clampTime(Math.min(1, Math.max(0, ratio)) * totalSec);
            updatePlaybackUI(true);
        }

        function jumpToSegment(direction) {
            if (!primaryData || !primaryData.segments.length) return;
            const nowMs = (audioPlayer.currentTime || 0) * 1000;
            let target = -1;

            if (direction > 0) {
                for (let i = 0; i < primaryData.segments.length; i++) {
                    if (primaryData.segments[i].startMs > nowMs + 20) {
                        target = i;
                        break;
                    }
                }
                if (target < 0) target = primaryData.segments.length - 1;
            } else {
                for (let i = primaryData.segments.length - 1; i >= 0; i--) {
                    if (primaryData.segments[i].startMs < nowMs - 20) {
                        target = i;
                        break;
                    }
                }
                if (target < 0) target = 0;
            }

            audioPlayer.currentTime = clampTime(primaryData.segments[target].startMs / 1000);
            updatePlaybackUI(true);
        }

        function setupDropZone(dropId, inputEl, textEl, onFile) {
            const drop = document.getElementById(dropId);
            drop.addEventListener('dragover', (event) => {
                event.preventDefault();
                drop.classList.add('drag-over');
            });
            drop.addEventListener('dragleave', () => drop.classList.remove('drag-over'));
            drop.addEventListener('drop', (event) => {
                event.preventDefault();
                drop.classList.remove('drag-over');
                const file = event.dataTransfer?.files?.[0];
                if (!file) return;
                inputEl.files = event.dataTransfer.files;
                textEl.textContent = file.name;
                onFile(file).catch((err) => alert(err.message));
            });
            inputEl.addEventListener('change', () => {
                const file = inputEl.files?.[0];
                if (!file) return;
                textEl.textContent = file.name;
                onFile(file).catch((err) => alert(err.message));
            });
        }

        async function handleAudioFile(file) {
            audioPlayer.src = URL.createObjectURL(file);
            await new Promise((resolve) => {
                audioPlayer.addEventListener('loadedmetadata', resolve, { once: true });
            });
            duration = audioPlayer.duration || 0;
            playBtn.disabled = false;
            timelinePlaceholder.style.display = 'none';
            renderTimelineSegments();
            updatePlaybackUI(true);
        }

        async function handlePrimaryJson(file) {
            primaryData = await loadWhisperFile(file);
            timelinePlaceholder.style.display = 'none';
            renderStats();
            renderTimelineSegments();
            renderSegments();
            renderComparison();
            updatePlaybackUI(true);
        }

        async function handleCompareJson(file) {
            compareData = await loadWhisperFile(file);
            renderComparison();
            updatePlaybackUI(true);
        }

        setupDropZone('audioDrop', audioFileInput, document.getElementById('audioDropText'), handleAudioFile);
        setupDropZone('jsonDrop', jsonFileInput, document.getElementById('jsonDropText'), handlePrimaryJson);
        setupDropZone('jsonCompareDrop', jsonCompareFileInput, document.getElementById('jsonCompareDropText'), handleCompareJson);

        playBtn.addEventListener('click', () => {
            if (audioPlayer.paused) {
                audioPlayer.play();
            } else {
                audioPlayer.pause();
            }
        });

        audioPlayer.addEventListener('play', () => {
            playIcon.textContent = '⏸';
            startPlaybackLoop();
        });

        audioPlayer.addEventListener('pause', () => {
            playIcon.textContent = '▶';
            stopPlaybackLoop();
            updatePlaybackUI(false);
        });

        audioPlayer.addEventListener('ended', () => {
            playIcon.textContent = '▶';
            stopPlaybackLoop();
            updatePlaybackUI(false);
        });

        speedSelect.addEventListener('change', () => {
            audioPlayer.playbackRate = Number(speedSelect.value) || 1;
        });

        timelineContainer.addEventListener('pointerdown', (event) => {
            isScrubbing = true;
            seekFromClientX(event.clientX);
            timelineContainer.setPointerCapture(event.pointerId);
        });

        timelineContainer.addEventListener('pointermove', (event) => {
            if (!isScrubbing) return;
            seekFromClientX(event.clientX);
        });

        timelineContainer.addEventListener('pointerup', (event) => {
            if (!isScrubbing) return;
            isScrubbing = false;
            timelineContainer.releasePointerCapture(event.pointerId);
        });

        timelineContainer.addEventListener('pointercancel', () => {
            isScrubbing = false;
        });

        document.addEventListener('keydown', (event) => {
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
                return;
            }

            const totalSec = getTotalDurationSeconds();
            switch (event.code) {
                case 'Space':
                    event.preventDefault();
                    if (!playBtn.disabled) playBtn.click();
                    break;
                case 'ArrowLeft':
                    audioPlayer.currentTime = clampTime((audioPlayer.currentTime || 0) - 5);
                    break;
                case 'ArrowRight':
                    audioPlayer.currentTime = clampTime((audioPlayer.currentTime || 0) + 5);
                    break;
                case 'KeyJ':
                    audioPlayer.currentTime = clampTime((audioPlayer.currentTime || 0) - 1);
                    break;
                case 'KeyL':
                    audioPlayer.currentTime = clampTime((audioPlayer.currentTime || 0) + 1);
                    break;
                case 'Home':
                    audioPlayer.currentTime = 0;
                    break;
                case 'KeyN':
                    jumpToSegment(1);
                    break;
                case 'KeyP':
                    jumpToSegment(-1);
                    break;
                default:
                    return;
            }

            if (totalSec > 0) updatePlaybackUI(true);
        });

        renderStats();
    </script>
</body>
</html>
